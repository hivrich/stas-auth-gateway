'use strict';
const { Pool } = require('pg');
let pool;
const getPool = () => pool ?? (pool = new Pool({ connectionString: process.env.STAS_PGURL }));

// ---- rate-limit (per user_id)
const RL_MAX = Number(process.env.RATE_LIMIT_EVENTS || 5);
const RL_WIN = Number(process.env.RATE_WINDOW_MS || 60_000);
const rlBuckets = new Map(); // uid -> [ts, ts, ...]

const yes = v => /^(1|true|yes|on)$/i.test((v??'').toString());
const isDry = q => yes(q?.dry_run);
const normAthlete = v => (v ? (String(v).trim().startsWith('i') ? String(v).trim() : `i${String(v).trim()}`) : null);
const b64 = key => `Basic ${Buffer.from(`API_KEY:${key}`).toString('base64')}`;

function rlAllow(uid){
  const now = Date.now();
  const arr = rlBuckets.get(uid)?.filter(ts => now - ts < RL_WIN) || [];
  if (arr.length >= RL_MAX) return { ok:false, retryAfterMs: RL_WIN - (now - arr[0]) };
  arr.push(now); rlBuckets.set(uid, arr);
  return { ok:true };
}

module.exports = app => {
  console.log('[v2][load] icu_post_real_gw');

  app.post('/gw/icu/events', async (req, res) => {
    const hasAuth = /^bearer\s+/i.test(req.get('authorization')||'');
    const uid = res.locals.user_id || req.query?.user_id || null;
    const events = Array.isArray(req.body?.events) ? req.body.events : [];

    if (!hasAuth || !uid) return res.status(401).json({ status:401, error:'missing_or_invalid_token' });
    if (!events.length)   return res.status(400).json({ status:400, error:'no_events' });

    // rate-limit (не ограничиваем dry_run)
    if (!isDry(req.query)) {
      const gate = rlAllow(uid);
      if (!gate.ok) {
        const secs = Math.ceil(gate.retryAfterMs/1000);
        res.set('Retry-After', String(secs));
        return res.status(429).json({ status:429, error:'rate_limited', retry_after_sec: secs, limit: RL_MAX, window_ms: RL_WIN });
      }
    }

    if (isDry(req.query)) return res.json({ ok:true, dry_run:true, count: events.length });

    try {
      const sql = 'select "api_key","athlete_id" from "user" where "id"=$1 limit 1';
      const { rows } = await getPool().query(sql, [uid]);
      if (!rows?.length) return res.status(400).json({ status:400, error:'icu_creds_not_found' });

      const api_key = rows[0].api_key;
      const athlete = normAthlete(rows[0].athlete_id);
      if (!api_key || !athlete) {
        return res.status(400).json({ status:400, error:'icu_creds_invalid', missing:{ api_key:!api_key, athlete_id:!athlete } });
      }

      const base = process.env.ICU_BASE_URL || 'https://intervals.icu/api/v1';
      const url  = `${base}/athlete/${athlete}/events/bulk?upsert=true`;
      const dry = String(req.query?.dry_run ?? "").toLowerCase();
      const isDry = (dry==="true"||dry==="1"||dry==="yes");
      const urlWithDry = url + (isDry ? "&dry_run=true" : "");
      const payload = events.map(e => {
        if (e && !e.external_id && e.externalId) {
          e = { ...e, external_id: e.externalId }; delete e.externalId;
        }
        return e;
      });

      const r = await fetch(url, {
        method: 'POST',
        headers: { Authorization: b64(api_key), 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const t = await r.text().catch(()=> '');
      if (!r.ok) {
        console.error('[icu_real][upstream]', r.status, t.slice(0,300));
        require("../metrics").incErr(uid);
        return res.status(r.status).json({ status:r.status, error:'icu_upstream_error', detail:t });
      }
      return res.json({ ok:true, count: events.length, upstream_status: r.status });
    } catch (e) {
      console.error('[icu_real][err]', e?.message);
      require("../metrics").incErr(uid);
      return res.status(502).json({ status:502, error:'icu_upstream_error', detail:e?.message });
    }
  });
};
